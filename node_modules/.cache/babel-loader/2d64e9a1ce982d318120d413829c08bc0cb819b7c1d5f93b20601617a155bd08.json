{"ast":null,"code":"/**\n * Terminal Service\n * \n * This module provides functions to interact with a simulated shell.\n * In a real application, these would make API calls to a backend service.\n * For this demo, we'll simulate shell commands and responses.\n */\n\n// Base directory for the file system - should match what's used in fileService\nconst BASE_DIRECTORY = '/Users/georgeseib/Documents/projects/cc/third';\n\n// In-memory filesystem to track created/modified files and directories\n// Export a getter function to allow other modules to access the filesystem\nexport const getVirtualFileSystem = () => virtualFileSystem;\nconst virtualFileSystem = {\n  // Initial directories\n  directories: ['',\n  // Root\n  'src', 'src/components', 'src/services', 'public', 'node_modules'],\n  // Initial files with their content\n  files: {\n    'package.json': `{\n  \"name\": \"third\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"description\": \"Web interface with Claude chat, file viewer, and terminal\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"^5.0.1\",\n    \"styled-components\": \"^6.1.1\",\n    \"xterm\": \"^5.3.0\",\n    \"xterm-addon-fit\": \"^0.8.0\",\n    \"axios\": \"^1.6.0\"\n  }\n}`,\n    'README.md': `# Claude Web Interface\n\nA web interface application with three panels for interacting with Claude:\n\n- **Left Panel**: Chat interface for conversing with Claude\n- **Upper Right Panel**: File viewer for browsing local repository files\n- **Bottom Right Panel**: Terminal for running commands (gh, npm, etc.)`,\n    'src/index.js': `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './index.css';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);`,\n    'src/App.js': `import React from 'react';\nimport styled from 'styled-components';\nimport ChatWindow from './components/ChatWindow';\nimport FileViewer from './components/FileViewer';\nimport Terminal from './components/Terminal';\n\nfunction App() {\n  return (\n    <AppContainer>\n      <ChatContainer>\n        <ChatWindow />\n      </ChatContainer>\n      <FileViewerContainer>\n        <FileViewer />\n      </FileViewerContainer>\n      <TerminalContainer>\n        <Terminal />\n      </TerminalContainer>\n    </AppContainer>\n  );\n}\n\nexport default App;`,\n    'src/index.css': `body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}`,\n    'src/components/ChatWindow.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// Chat window component implementation\nexport default function ChatWindow() {\n  return <div>Chat Window</div>;\n}`,\n    'src/components/FileViewer.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// File viewer component implementation\nexport default function FileViewer() {\n  return <div>File Viewer</div>;\n}`,\n    'src/components/Terminal.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// Terminal component implementation\nexport default function Terminal() {\n  return <div>Terminal</div>;\n}`,\n    'src/services/fileService.js': `// File service implementation`,\n    'src/services/terminalService.js': `// Terminal service implementation`,\n    'public/index.html': `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Claude Web Interface</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n  </body>\n</html>`\n  }\n};\n\n/**\n * Execute a shell command\n * @param {string} command - Command to execute\n * @param {string} currentDirectory - Current working directory\n * @returns {Promise<{output: string, newDirectory: string}>} - Command output and new working directory\n */\nexport const executeCommand = async (command, currentDirectory = '') => {\n  // In a real implementation, this would call a backend API\n  // For demo purposes, we'll simulate responses to common commands\n\n  // Simulate network delay\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  // Trim command\n  command = command.trim();\n\n  // Determine the full path of the current directory\n  const workingDir = currentDirectory || '';\n  const fullPath = workingDir ? `${BASE_DIRECTORY}/${workingDir}` : BASE_DIRECTORY;\n\n  // Check for redirection\n  let redirectOutput = false;\n  let redirectAppend = false;\n  let redirectFile = '';\n  let originalCommand = command;\n\n  // Check for output redirection\n  if (command.includes('>>')) {\n    redirectOutput = true;\n    redirectAppend = true;\n    [command, redirectFile] = command.split('>>').map(part => part.trim());\n  } else if (command.includes('>')) {\n    redirectOutput = true;\n    redirectAppend = false;\n    [command, redirectFile] = command.split('>').map(part => part.trim());\n  }\n\n  // Parse command and arguments - handle quoted arguments properly\n  const args = parseCommandArgs(command);\n  const cmd = args.length > 0 ? args[0].toLowerCase() : '';\n\n  // Track the new directory (changes if cd is used)\n  let newDirectory = currentDirectory;\n\n  // Simulate command execution\n  let output = '';\n  try {\n    // Handle different commands\n    switch (cmd) {\n      // File system navigation\n      case 'ls':\n        output = simulateLS(args, workingDir);\n        break;\n      case 'cd':\n        const cdResult = simulateCD(args, workingDir);\n        output = cdResult.output;\n        newDirectory = cdResult.newDirectory;\n        break;\n      case 'pwd':\n        output = simulatePWD(workingDir);\n        break;\n\n      // File operations\n      case 'cat':\n        output = simulateCAT(args, workingDir);\n        break;\n      case 'touch':\n        output = simulateTOUCH(args, workingDir);\n        break;\n      case 'mkdir':\n        output = simulateMKDIR(args, workingDir);\n        break;\n      case 'rm':\n        output = simulateRM(args, workingDir);\n        break;\n      case 'cp':\n        output = simulateCP(args, workingDir);\n        break;\n      case 'mv':\n        output = simulateMV(args, workingDir);\n        break;\n      case 'find':\n        output = simulateFIND(args, workingDir);\n        break;\n      case 'grep':\n        output = simulateGREP(args, workingDir);\n        break;\n\n      // Text output\n      case 'echo':\n        output = simulateECHO(args);\n        break;\n\n      // External tools\n      case 'npm':\n        output = simulateNPM(args, workingDir);\n        break;\n      case 'node':\n        output = simulateNODE(args, workingDir);\n        break;\n      case 'gh':\n        output = simulateGH(args, workingDir);\n        break;\n      case 'git':\n        output = simulateGit(args, workingDir);\n        break;\n\n      // System commands\n      case 'ps':\n        output = simulatePS(args);\n        break;\n      case 'whoami':\n        output = 'user';\n        break;\n      case 'date':\n        output = new Date().toString();\n        break;\n      case 'help':\n        output = getHelpText();\n        break;\n      case 'man':\n        output = simulateMAN(args);\n        break;\n      case 'clear':\n        // The clear command returns a special signal to clear the terminal\n        return {\n          output: 'CLEAR_TERMINAL',\n          newDirectory\n        };\n      case '':\n        // Empty command, do nothing\n        output = '';\n        break;\n      default:\n        // Check if this is an executable file in the current directory\n        if (fileExists(`${workingDir ? workingDir + '/' : ''}${cmd}`)) {\n          output = `Simulated execution of ${cmd}`;\n        } else {\n          output = `Command not found: ${cmd}\\nType 'help' to see available commands.`;\n        }\n    }\n  } catch (error) {\n    output = `Error: ${error.message}`;\n  }\n  return {\n    output,\n    newDirectory\n  };\n};\n\n/**\n * Simulate the 'ls' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateLS(args, workingDir) {\n  // Check for -l flag\n  const isLongFormat = args.includes('-l');\n\n  // Get mock file listing based on the current directory\n  const files = getMockFileListing(workingDir);\n  if (isLongFormat) {\n    // Format like a real ls -l command\n    return files.map(file => {\n      const isDir = file.type === 'folder';\n      const permissions = isDir ? 'drwxr-xr-x' : '-rw-r--r--';\n      const size = isDir ? 4096 : Math.floor(Math.random() * 10000);\n      const date = new Date().toLocaleDateString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n      return `${permissions} 1 user group ${size.toString().padStart(6)} ${date} ${file.name}${isDir ? '/' : ''}`;\n    }).join('\\n');\n  } else {\n    // Simple format\n    return files.map(file => {\n      return file.type === 'folder' ? `${file.name}/` : file.name;\n    }).join('  ');\n  }\n}\n\n/**\n * Simulate the 'cd' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {{output: string, newDirectory: string}} - Command output and new working directory\n */\nfunction simulateCD(args, workingDir) {\n  if (args.length < 2) {\n    // cd without arguments goes to home directory\n    return {\n      output: '',\n      newDirectory: ''\n    };\n  }\n  const target = args[1];\n  if (target === '..') {\n    // Go up one directory\n    if (!workingDir || !workingDir.includes('/')) {\n      return {\n        output: '',\n        newDirectory: ''\n      };\n    }\n    const newDir = workingDir.substring(0, workingDir.lastIndexOf('/'));\n    return {\n      output: '',\n      newDirectory: newDir\n    };\n  }\n  if (target === '.') {\n    // Stay in current directory\n    return {\n      output: '',\n      newDirectory: workingDir\n    };\n  }\n  if (target.startsWith('/')) {\n    // Absolute path (within our mock filesystem)\n    const newDir = target.substring(1); // Remove leading slash\n\n    // Check if directory exists\n    if (directoryExists(newDir)) {\n      return {\n        output: '',\n        newDirectory: newDir\n      };\n    } else {\n      return {\n        output: `cd: ${target}: No such file or directory`,\n        newDirectory: workingDir\n      };\n    }\n  }\n\n  // Relative path\n  const newDir = workingDir ? `${workingDir}/${target}` : target;\n\n  // Check if directory exists\n  if (directoryExists(newDir)) {\n    return {\n      output: '',\n      newDirectory: newDir\n    };\n  } else {\n    return {\n      output: `cd: ${target}: No such file or directory`,\n      newDirectory: workingDir\n    };\n  }\n}\n\n/**\n * Simulate the 'pwd' command\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulatePWD(workingDir) {\n  return workingDir ? `/${workingDir}` : '/';\n}\n\n/**\n * Simulate the 'cat' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateCAT(args, workingDir) {\n  if (args.length < 2) {\n    return 'cat: missing file operand';\n  }\n  const filename = args[1];\n  const path = resolveFilePath(filename, workingDir);\n\n  // Check if file exists\n  if (fileExists(path)) {\n    return getMockFileContent(path);\n  } else {\n    return `cat: ${filename}: No such file or directory`;\n  }\n}\n\n/**\n * Simulate the 'mkdir' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateMKDIR(args, workingDir) {\n  if (args.length < 2) {\n    return 'mkdir: missing operand';\n  }\n\n  // Check for -p flag (create parent directories as needed)\n  const createParents = args.includes('-p');\n\n  // Get targets (ignore option flags)\n  const targets = args.slice(1).filter(arg => !arg.startsWith('-'));\n  if (targets.length === 0) {\n    return 'mkdir: missing operand';\n  }\n  for (const target of targets) {\n    const path = resolveFilePath(target, workingDir);\n\n    // Check if directory already exists\n    if (directoryExists(path)) {\n      if (!createParents) {\n        return `mkdir: cannot create directory '${target}': File exists`;\n      }\n      // With -p, we just continue if the directory exists\n      continue;\n    }\n\n    // Check if a file with the same name exists\n    if (fileExists(path)) {\n      return `mkdir: cannot create directory '${target}': File exists`;\n    }\n\n    // Check if parent directory exists\n    const parentDir = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';\n    if (parentDir && !directoryExists(parentDir)) {\n      if (createParents) {\n        // Create parent directories recursively\n        const parts = path.split('/');\n        let currentPath = '';\n        for (let i = 0; i < parts.length; i++) {\n          if (parts[i] === '') continue;\n          if (currentPath === '') {\n            currentPath = parts[i];\n          } else {\n            currentPath += '/' + parts[i];\n          }\n          if (!directoryExists(currentPath)) {\n            createDirectory(currentPath);\n          }\n        }\n      } else {\n        return `mkdir: cannot create directory '${target}': No such file or directory`;\n      }\n    } else {\n      // Create the directory\n      createDirectory(path);\n    }\n  }\n  return '';\n}\n\n/**\n * Simulate the 'npm' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateNPM(args, workingDir) {\n  if (args.length < 2) {\n    return 'npm: missing command';\n  }\n  const subCommand = args[1];\n  switch (subCommand) {\n    case 'start':\n      return 'Starting development server...\\n\\nCompiled successfully!\\n\\nYou can now view the app in the browser.\\n\\n  Local:            http://localhost:3000\\n  On Your Network:  http://192.168.0.45:3000';\n    case 'test':\n      return 'PASS  src/__tests__/app.test.js\\nPASS  src/__tests__/components.test.js\\n\\nTest Suites: 2 passed, 2 total\\nTests:       7 passed, 7 total\\nSnapshots:   0 total\\nTime:        1.234s';\n    case 'build':\n      return 'Creating an optimized production build...\\nCompiled successfully.\\n\\nFile sizes after gzip:\\n\\n  142.32 KB  build/static/js/main.a1b2c3d4.js\\n  23.45 KB   build/static/css/main.a1b2c3d4.css';\n    case 'install':\n      const packageName = args.length > 2 ? args[2] : '';\n      if (packageName) {\n        return `+ ${packageName}@1.2.3\\nadded 42 packages from 23 contributors in 2.5s`;\n      } else {\n        return 'added 1344 packages in 30s';\n      }\n    default:\n      return `Unknown npm command: ${subCommand}`;\n  }\n}\n\n/**\n * Simulate the 'gh' (GitHub CLI) command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGH(args, workingDir) {\n  if (args.length < 2) {\n    return 'gh: missing command';\n  }\n  const subCommand = args[1];\n  switch (subCommand) {\n    case 'pr':\n      if (args.length < 3) {\n        return 'gh pr: missing subcommand';\n      }\n      const prSubCommand = args[2];\n      switch (prSubCommand) {\n        case 'list':\n          return 'Showing 2 of 2 open pull requests in username/repo\\n\\n#42  Update documentation  user1  [feature/docs]  1d\\n#41  Fix terminal component  user2  [bugfix/terminal]  2d';\n        case 'create':\n          return 'Creating pull request for feature-branch into main in username/repo\\n\\nPull request created: https://github.com/username/repo/pull/43';\n        default:\n          return `Unknown gh pr command: ${prSubCommand}`;\n      }\n    case 'issue':\n      return 'Showing 3 of 3 open issues in username/repo\\n\\n#39  Improve performance  user1  2d\\n#38  Add test coverage  user2  3d\\n#37  Update dependencies  user3  1w';\n    default:\n      return `Unknown gh command: ${subCommand}`;\n  }\n}\n\n/**\n * Simulate the 'git' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGit(args, workingDir) {\n  if (args.length < 2) {\n    return 'git: missing command';\n  }\n  const subCommand = args[1];\n  switch (subCommand) {\n    case 'status':\n      return 'On branch main\\nYour branch is up to date with \\'origin/main\\'.\\n\\nChanges not staged for commit:\\n  (use \"git add <file>...\" to update what will be committed)\\n  (use \"git restore <file>...\" to discard changes in working directory)\\n        modified:   src/components/Terminal.js\\n        modified:   src/components/FileViewer.js\\n\\nno changes added to commit (use \"git add\" and/or \"git commit -a\")';\n    case 'add':\n      return '';\n    case 'commit':\n      return '[main a1b2c3d] Update terminal and file viewer components\\n 2 files changed, 150 insertions(+), 20 deletions(-)';\n    case 'push':\n      return 'Enumerating objects: 7, done.\\nCounting objects: 100% (7/7), done.\\nDelta compression using up to 8 threads\\nCompressing objects: 100% (4/4), done.\\nWriting objects: 100% (4/4), 1.23 KiB | 1.23 MiB/s, done.\\nTotal 4 (delta 3), reused 0 (delta 0), pack-reused 0\\nremote: Resolving deltas: 100% (3/3), completed with 3 local objects.\\nTo github.com:username/repo.git\\n   a1b2c3d..e4f5g6h  main -> main';\n    case 'log':\n      return 'commit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t\\nAuthor: User <user@example.com>\\nDate:   Mon Mar 1 12:34:56 2024 -0800\\n\\n    Update terminal and file viewer components\\n\\ncommit b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\\nAuthor: User <user@example.com>\\nDate:   Sun Feb 29 12:34:56 2024 -0800\\n\\n    Initial commit';\n    case 'branch':\n      return '* main\\n  feature/file-viewer\\n  feature/terminal';\n    case 'checkout':\n      const branchName = args.length > 2 ? args[2] : 'main';\n      return `Switched to branch '${branchName}'`;\n    default:\n      return `Unknown git command: ${subCommand}`;\n  }\n}\n\n/**\n * Get help text for available commands\n * @returns {string} - Help text\n */\n/**\n * Parse command arguments, handling quoted strings correctly\n * @param {string} commandLine - Command line to parse\n * @returns {string[]} - Array of parsed arguments\n */\nfunction parseCommandArgs(commandLine) {\n  const args = [];\n  let currentArg = '';\n  let inQuote = false;\n  let quoteChar = '';\n  for (let i = 0; i < commandLine.length; i++) {\n    const char = commandLine[i];\n    if ((char === '\"' || char === \"'\") && (!inQuote || quoteChar === char)) {\n      if (inQuote) {\n        inQuote = false;\n        quoteChar = '';\n      } else {\n        inQuote = true;\n        quoteChar = char;\n      }\n      continue;\n    }\n    if (char === ' ' && !inQuote) {\n      if (currentArg) {\n        args.push(currentArg);\n        currentArg = '';\n      }\n      continue;\n    }\n    currentArg += char;\n  }\n  if (currentArg) {\n    args.push(currentArg);\n  }\n  return args;\n}\n\n/**\n * Simulate the 'echo' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulateECHO(args) {\n  // Skip the 'echo' command itself\n  return args.slice(1).join(' ');\n}\n\n/**\n * Simulate the 'touch' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateTOUCH(args, workingDir) {\n  if (args.length < 2) {\n    return 'touch: missing file operand';\n  }\n\n  // Get all file operands (skipping the command itself)\n  const files = args.slice(1);\n  for (const file of files) {\n    const path = resolveFilePath(file, workingDir);\n\n    // Check if parent directory exists\n    const parentDir = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';\n    if (parentDir && !directoryExists(parentDir)) {\n      return `touch: cannot touch '${file}': No such file or directory`;\n    }\n\n    // Create the file if it doesn't exist\n    if (!fileExists(path)) {\n      createFile(path, '');\n    } else {\n      // In a real touch, this would update the timestamp\n      // We'll just do nothing for existing files\n    }\n  }\n  return '';\n}\n\n/**\n * Simulate the 'rm' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateRM(args, workingDir) {\n  if (args.length < 2) {\n    return 'rm: missing operand';\n  }\n  const isRecursive = args.includes('-r') || args.includes('-rf') || args.includes('-fr');\n  const isForce = args.includes('-f') || args.includes('-rf') || args.includes('-fr');\n\n  // Get targets (ignore option flags)\n  const targets = args.slice(1).filter(arg => !arg.startsWith('-'));\n  if (targets.length === 0) {\n    return 'rm: missing operand';\n  }\n  for (const target of targets) {\n    const path = resolveFilePath(target, workingDir);\n    if (fileExists(path)) {\n      // Remove file\n      removeFile(path);\n    } else if (directoryExists(path)) {\n      // Remove directory\n      if (!isRecursive) {\n        return `rm: cannot remove '${target}': Is a directory`;\n      } else {\n        removeDirectory(path, true);\n      }\n    } else if (!isForce) {\n      return `rm: cannot remove '${target}': No such file or directory`;\n    }\n  }\n  return '';\n}\n\n/**\n * Simulate the 'cp' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateCP(args, workingDir) {\n  if (args.length < 3) {\n    return 'cp: missing file operand';\n  }\n  const isRecursive = args.includes('-r') || args.includes('-R');\n\n  // Get all arguments that aren't flags\n  const nonFlagArgs = args.filter(arg => !arg.startsWith('-'));\n\n  // Need at least a source and destination\n  if (nonFlagArgs.length < 3) {\n    return 'cp: missing destination file operand after ' + nonFlagArgs[1];\n  }\n\n  // Last argument is the destination\n  const destination = resolveFilePath(nonFlagArgs[nonFlagArgs.length - 1], workingDir);\n\n  // All other non-flag arguments except the command itself are sources\n  const sources = nonFlagArgs.slice(1, nonFlagArgs.length - 1).map(src => resolveFilePath(src, workingDir));\n\n  // If copying multiple sources, destination must be a directory\n  if (sources.length > 1 && !directoryExists(destination)) {\n    return `cp: target '${nonFlagArgs[nonFlagArgs.length - 1]}' is not a directory`;\n  }\n  for (const source of sources) {\n    if (fileExists(source)) {\n      // Copying a file\n\n      // Determine the destination path\n      let destPath = destination;\n      if (directoryExists(destination)) {\n        // If destination is a directory, copy into it with the same name\n        const fileName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destPath = destination + '/' + fileName;\n      }\n\n      // Copy the file content\n      createFile(destPath, virtualFileSystem.files[source]);\n    } else if (directoryExists(source)) {\n      // Copying a directory\n\n      if (!isRecursive) {\n        return `cp: -r not specified; omitting directory '${source}'`;\n      }\n\n      // Determine the destination directory path\n      let destDirPath = destination;\n      if (directoryExists(destination)) {\n        // If destination already exists as a directory, create a subdirectory\n        const dirName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destDirPath = destination + '/' + dirName;\n\n        // Create the destination directory if it doesn't exist\n        if (!directoryExists(destDirPath)) {\n          createDirectory(destDirPath);\n        }\n      } else {\n        // Create the destination directory\n        createDirectory(destDirPath);\n      }\n\n      // Copy all files and subdirectories recursively\n      // Find all subdirectories\n      const subdirs = virtualFileSystem.directories.filter(dir => dir !== source && dir.startsWith(source + '/'));\n\n      // Create all subdirectories in the destination\n      for (const subdir of subdirs) {\n        const relativePath = subdir.substring(source.length);\n        createDirectory(destDirPath + relativePath);\n      }\n\n      // Copy all files\n      const filesInDir = Object.keys(virtualFileSystem.files).filter(file => file.startsWith(source + '/'));\n      for (const file of filesInDir) {\n        const relativePath = file.substring(source.length);\n        createFile(destDirPath + relativePath, virtualFileSystem.files[file]);\n      }\n    } else {\n      return `cp: cannot stat '${nonFlagArgs[sources.indexOf(source) + 1]}': No such file or directory`;\n    }\n  }\n  return '';\n}\n\n/**\n * Simulate the 'mv' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateMV(args, workingDir) {\n  if (args.length < 3) {\n    return 'mv: missing file operand';\n  }\n\n  // Get all arguments except the command itself\n  const nonFlagArgs = args.filter(arg => !arg.startsWith('-'));\n\n  // Need at least a source and destination\n  if (nonFlagArgs.length < 3) {\n    return 'mv: missing destination file operand after ' + nonFlagArgs[1];\n  }\n\n  // Last argument is the destination\n  const destination = resolveFilePath(nonFlagArgs[nonFlagArgs.length - 1], workingDir);\n\n  // All other non-flag arguments except the command itself are sources\n  const sources = nonFlagArgs.slice(1, nonFlagArgs.length - 1).map(src => resolveFilePath(src, workingDir));\n\n  // If moving multiple sources, destination must be a directory\n  if (sources.length > 1 && !directoryExists(destination)) {\n    return `mv: target '${nonFlagArgs[nonFlagArgs.length - 1]}' is not a directory`;\n  }\n  for (const source of sources) {\n    if (fileExists(source)) {\n      // Moving a file\n\n      // Determine the destination path\n      let destPath = destination;\n      if (directoryExists(destination)) {\n        // If destination is a directory, move into it with the same name\n        const fileName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destPath = destination + '/' + fileName;\n      }\n\n      // Move the file (copy then delete)\n      createFile(destPath, virtualFileSystem.files[source]);\n      removeFile(source);\n    } else if (directoryExists(source)) {\n      // Moving a directory\n\n      // Determine the destination directory path\n      let destDirPath = destination;\n      if (directoryExists(destination)) {\n        // If destination already exists as a directory, create a subdirectory\n        const dirName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destDirPath = destination + '/' + dirName;\n\n        // Create the destination directory if it doesn't exist\n        if (!directoryExists(destDirPath)) {\n          createDirectory(destDirPath);\n        }\n      } else {\n        // Create the destination directory\n        createDirectory(destDirPath);\n      }\n\n      // Move all files and subdirectories\n      // Find all subdirectories\n      const subdirs = virtualFileSystem.directories.filter(dir => dir !== source && dir.startsWith(source + '/'));\n\n      // Create all subdirectories in the destination\n      for (const subdir of subdirs) {\n        const relativePath = subdir.substring(source.length);\n        createDirectory(destDirPath + relativePath);\n      }\n\n      // Move all files\n      const filesInDir = Object.keys(virtualFileSystem.files).filter(file => file.startsWith(source + '/'));\n      for (const file of filesInDir) {\n        const relativePath = file.substring(source.length);\n        createFile(destDirPath + relativePath, virtualFileSystem.files[file]);\n        removeFile(file);\n      }\n\n      // Remove the source directory and all subdirectories\n      for (const subdir of [...subdirs].reverse()) {\n        removeDirectory(subdir);\n      }\n      removeDirectory(source);\n    } else {\n      return `mv: cannot stat '${nonFlagArgs[sources.indexOf(source) + 1]}': No such file or directory`;\n    }\n  }\n  return '';\n}\n\n/**\n * Simulate the 'find' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateFIND(args, workingDir) {\n  // Basic implementation of find\n  // find [path] -name \"pattern\"\n\n  let path = '.';\n  let pattern = null;\n\n  // Parse arguments\n  for (let i = 1; i < args.length; i++) {\n    if (args[i] === '-name' && i + 1 < args.length) {\n      pattern = args[i + 1];\n      i++; // Skip the next argument\n    } else if (!args[i].startsWith('-') && i === 1) {\n      path = args[i];\n    }\n  }\n  if (!pattern) {\n    return 'find: missing arguments';\n  }\n\n  // Remove quotes if present\n  pattern = pattern.replace(/^['\"]|['\"]$/g, '');\n\n  // Convert glob pattern to regex\n  const regexPattern = pattern.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*').replace(/\\?/g, '.');\n  const regex = new RegExp(`^${regexPattern}$`);\n\n  // Get file listing for the path\n  const searchPath = path === '.' ? workingDir : resolveFilePath(path, workingDir);\n\n  // In a real implementation, this would search for files\n  // For our demo, we'll return a simulated result\n\n  // Create a reasonable list of matches based on the pattern\n  const matches = [];\n  const files = getMockFileListing(searchPath);\n  for (const file of files) {\n    if (regex.test(file.name)) {\n      matches.push(`${searchPath ? searchPath + '/' : ''}${file.name}`);\n    }\n  }\n  return matches.length > 0 ? matches.join('\\n') : '';\n}\n\n/**\n * Simulate the 'grep' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGREP(args, workingDir) {\n  if (args.length < 3) {\n    return 'grep: missing pattern';\n  }\n  const pattern = args[1];\n  const filePaths = args.slice(2);\n\n  // In a real implementation, this would search file contents\n  // For our demo, we'll return simulated results\n\n  const results = [];\n  for (const filePath of filePaths) {\n    const path = resolveFilePath(filePath, workingDir);\n    if (fileExists(path)) {\n      const content = getMockFileContent(path);\n      const lines = content.split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].includes(pattern)) {\n          results.push(`${filePath}:${i + 1}: ${lines[i]}`);\n        }\n      }\n    } else {\n      results.push(`grep: ${filePath}: No such file or directory`);\n    }\n  }\n  return results.join('\\n');\n}\n\n/**\n * Simulate the 'ps' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulatePS(args) {\n  const header = '  PID TTY          TIME CMD';\n  const processes = [' 1234 pts/0    00:00:01 bash', ' 5678 pts/0    00:00:00 npm', ' 9012 pts/0    00:00:12 node', '13456 pts/0    00:00:00 ps'];\n  return [header, ...processes].join('\\n');\n}\n\n/**\n * Simulate the 'node' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateNODE(args, workingDir) {\n  if (args.length === 1) {\n    return 'Welcome to Node.js v18.16.0.\\nType \".help\" for more information.';\n  }\n  const scriptPath = args[1];\n  const path = resolveFilePath(scriptPath, workingDir);\n  if (fileExists(path)) {\n    return `Simulated execution of Node.js script: ${scriptPath}`;\n  } else {\n    return `Error: Cannot find module '${scriptPath}'`;\n  }\n}\n\n/**\n * Simulate the 'man' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulateMAN(args) {\n  if (args.length < 2) {\n    return 'What manual page do you want?';\n  }\n  const command = args[1];\n  const manPages = {\n    'ls': 'LS(1)                    User Commands                   LS(1)\\n\\nNAME\\n       ls - list directory contents\\n\\nSYNOPSIS\\n       ls [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       List information about the FILEs (the current directory by default).',\n    'cd': 'CD(1)                    User Commands                   CD(1)\\n\\nNAME\\n       cd - change directory\\n\\nSYNOPSIS\\n       cd [directory]\\n\\nDESCRIPTION\\n       Change the current directory to the specified directory.',\n    'cat': 'CAT(1)                  User Commands                   CAT(1)\\n\\nNAME\\n       cat - concatenate files and print on the standard output\\n\\nSYNOPSIS\\n       cat [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       Concatenate FILE(s) to standard output.',\n    'mkdir': 'MKDIR(1)               User Commands                 MKDIR(1)\\n\\nNAME\\n       mkdir - make directories\\n\\nSYNOPSIS\\n       mkdir [OPTION]... DIRECTORY...\\n\\nDESCRIPTION\\n       Create the DIRECTORY(ies), if they do not already exist.',\n    'touch': 'TOUCH(1)               User Commands                 TOUCH(1)\\n\\nNAME\\n       touch - change file timestamps\\n\\nSYNOPSIS\\n       touch [OPTION]... FILE...\\n\\nDESCRIPTION\\n       Update the access and modification times of each FILE to the current time.',\n    'rm': 'RM(1)                    User Commands                   RM(1)\\n\\nNAME\\n       rm - remove files or directories\\n\\nSYNOPSIS\\n       rm [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       Remove (unlink) the FILE(s).',\n    'cp': 'CP(1)                    User Commands                   CP(1)\\n\\nNAME\\n       cp - copy files and directories\\n\\nSYNOPSIS\\n       cp [OPTION]... SOURCE DEST\\n\\nDESCRIPTION\\n       Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.',\n    'mv': 'MV(1)                    User Commands                   MV(1)\\n\\nNAME\\n       mv - move (rename) files\\n\\nSYNOPSIS\\n       mv [OPTION]... SOURCE DEST\\n\\nDESCRIPTION\\n       Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.',\n    'find': 'FIND(1)                  User Commands                 FIND(1)\\n\\nNAME\\n       find - search for files in a directory hierarchy\\n\\nSYNOPSIS\\n       find [path...] [expression]\\n\\nDESCRIPTION\\n       Search for files in a directory hierarchy.',\n    'grep': 'GREP(1)                  User Commands                 GREP(1)\\n\\nNAME\\n       grep - print lines that match patterns\\n\\nSYNOPSIS\\n       grep [OPTION...] PATTERNS [FILE...]\\n\\nDESCRIPTION\\n       Search for PATTERNS in each FILE.',\n    'echo': 'ECHO(1)                  User Commands                 ECHO(1)\\n\\nNAME\\n       echo - display a line of text\\n\\nSYNOPSIS\\n       echo [SHORT-OPTION]... [STRING]...\\n\\nDESCRIPTION\\n       Echo the STRING(s) to standard output.',\n    'pwd': 'PWD(1)                   User Commands                  PWD(1)\\n\\nNAME\\n       pwd - print name of current/working directory\\n\\nSYNOPSIS\\n       pwd [OPTION]...\\n\\nDESCRIPTION\\n       Print the full filename of the current working directory.'\n  };\n  return manPages[command] || `No manual entry for ${command}`;\n}\nfunction getHelpText() {\n  return `\nAvailable commands:\n\nFile Operations:\n  ls [options]           List directory contents\n  cd <directory>         Change directory\n  pwd                    Print working directory\n  touch <file>           Create an empty file\n  mkdir <directory>      Create directory\n  rm [-rf] <file/dir>    Remove files or directories\n  cp [-r] <src> <dst>    Copy files or directories\n  mv <src> <dst>         Move/rename files or directories\n  cat <file>             Display file contents\n  find <path> -name <p>  Search for files\n  grep <pattern> <file>  Search for a pattern in files\n\nGit Commands:\n  git status             Show git status\n  git add <file>         Stage changes\n  git commit -m <msg>    Commit changes\n  git push               Push changes\n  git log                Show commit history\n  git branch             List branches\n  git checkout <branch>  Switch branches\n  \nnpm Commands:\n  npm start              Start development server\n  npm test               Run tests\n  npm build              Build for production\n  npm install [pkg]      Install dependencies\n  \nGitHub CLI:\n  gh pr list             List pull requests\n  gh pr create           Create pull request\n  gh issue               List issues\n  \nSystem Commands:\n  echo <text>            Display a line of text\n  date                   Show the current date and time\n  ps                     Report process status\n  whoami                 Print current user\n  man <command>          Display manual page\n  clear                  Clear the terminal screen\n  help                   Show this help\n`.trim();\n}\n\n/**\n * Check if a directory exists in our virtual filesystem\n * @param {string} path - Directory path\n * @returns {boolean} - True if directory exists\n */\nfunction directoryExists(path) {\n  return virtualFileSystem.directories.includes(path);\n}\n\n/**\n * Create a directory in our virtual filesystem\n * @param {string} path - Directory path\n * @returns {boolean} - True if directory was created successfully\n */\nfunction createDirectory(path) {\n  if (directoryExists(path)) {\n    return false; // Directory already exists\n  }\n\n  // Add directory to virtual filesystem\n  virtualFileSystem.directories.push(path);\n  return true;\n}\n\n/**\n * Check if a file exists in our virtual filesystem\n * @param {string} path - File path\n * @returns {boolean} - True if file exists\n */\nfunction fileExists(path) {\n  return path in virtualFileSystem.files;\n}\n\n/**\n * Create a file in our virtual filesystem\n * @param {string} path - File path\n * @param {string} content - File content\n * @returns {boolean} - True if file was created successfully\n */\nfunction createFile(path, content = '') {\n  if (fileExists(path)) {\n    return false; // File already exists\n  }\n\n  // Add file to virtual filesystem\n  virtualFileSystem.files[path] = content;\n  return true;\n}\n\n/**\n * Remove a file from our virtual filesystem\n * @param {string} path - File path\n * @returns {boolean} - True if file was removed successfully\n */\nfunction removeFile(path) {\n  if (!fileExists(path)) {\n    return false; // File doesn't exist\n  }\n\n  // Remove file from virtual filesystem\n  delete virtualFileSystem.files[path];\n  return true;\n}\n\n/**\n * Remove a directory from our virtual filesystem\n * @param {string} path - Directory path\n * @param {boolean} recursive - Whether to remove subdirectories and files\n * @returns {boolean} - True if directory was removed successfully\n */\nfunction removeDirectory(path, recursive = false) {\n  if (!directoryExists(path)) {\n    return false; // Directory doesn't exist\n  }\n\n  // Check if directory is empty or recursive flag is set\n  const filesInDir = Object.keys(virtualFileSystem.files).filter(file => file.startsWith(path + '/') || file === path);\n  const dirsInDir = virtualFileSystem.directories.filter(dir => dir !== path && dir.startsWith(path + '/'));\n  if ((filesInDir.length > 0 || dirsInDir.length > 0) && !recursive) {\n    return false; // Directory not empty and recursive flag not set\n  }\n\n  // Remove files in directory if recursive\n  if (recursive) {\n    filesInDir.forEach(file => {\n      delete virtualFileSystem.files[file];\n    });\n\n    // Remove subdirectories\n    virtualFileSystem.directories = virtualFileSystem.directories.filter(dir => dir !== path && !dir.startsWith(path + '/'));\n  } else {\n    // Just remove the directory\n    virtualFileSystem.directories = virtualFileSystem.directories.filter(dir => dir !== path);\n  }\n  return true;\n}\n\n/**\n * Resolve a file path based on the current working directory\n * @param {string} filename - File name or path\n * @param {string} workingDir - Current working directory\n * @returns {string} - Resolved file path\n */\nfunction resolveFilePath(filename, workingDir) {\n  if (filename.startsWith('/')) {\n    // Absolute path (within our mock filesystem)\n    return filename.substring(1); // Remove leading slash\n  } else {\n    // Relative path\n    return workingDir ? `${workingDir}/${filename}` : filename;\n  }\n}\n\n// Removed previous implementation\n\n/**\n * Get file content from our virtual filesystem\n * @param {string} filePath - Path to the file\n * @returns {string} - File content\n */\nfunction getMockFileContent(filePath) {\n  // Return the file content from the virtual filesystem\n  if (fileExists(filePath)) {\n    return virtualFileSystem.files[filePath];\n  }\n  return `// File ${filePath} not found`;\n}\n\n/**\n * Get mock file listing based on directory\n * @param {string} directory - Directory path\n * @returns {Array} - Array of file and directory objects\n */\nfunction getMockFileListing(directory) {\n  // Get all subdirectories directly under the specified directory\n  const directSubdirs = virtualFileSystem.directories.filter(dir => {\n    if (directory === '') {\n      // For root directory, get top-level dirs (no slashes)\n      return dir !== '' && !dir.includes('/');\n    } else {\n      // For other directories, get direct children\n      return dir !== directory && dir.startsWith(directory + '/') && dir.substring(directory.length + 1).indexOf('/') === -1;\n    }\n  }).map(dir => {\n    return {\n      name: directory === '' ? dir : dir.substring(directory.length + 1),\n      type: 'folder'\n    };\n  });\n\n  // Get all files directly under the specified directory\n  const directFiles = Object.keys(virtualFileSystem.files).filter(file => {\n    if (directory === '') {\n      // For root directory, get top-level files (no slashes)\n      return !file.includes('/');\n    } else {\n      // For other directories, get direct children\n      return file.startsWith(directory + '/') && file.substring(directory.length + 1).indexOf('/') === -1;\n    }\n  }).map(file => {\n    return {\n      name: directory === '' ? file : file.substring(directory.length + 1),\n      type: 'file'\n    };\n  });\n\n  // Combine directories and files\n  return [...directSubdirs, ...directFiles];\n}","map":{"version":3,"names":["BASE_DIRECTORY","getVirtualFileSystem","virtualFileSystem","directories","files","executeCommand","command","currentDirectory","Promise","resolve","setTimeout","trim","workingDir","fullPath","redirectOutput","redirectAppend","redirectFile","originalCommand","includes","split","map","part","args","parseCommandArgs","cmd","length","toLowerCase","newDirectory","output","simulateLS","cdResult","simulateCD","simulatePWD","simulateCAT","simulateTOUCH","simulateMKDIR","simulateRM","simulateCP","simulateMV","simulateFIND","simulateGREP","simulateECHO","simulateNPM","simulateNODE","simulateGH","simulateGit","simulatePS","Date","toString","getHelpText","simulateMAN","fileExists","error","message","isLongFormat","getMockFileListing","file","isDir","type","permissions","size","Math","floor","random","date","toLocaleDateString","month","day","hour","minute","padStart","name","join","target","newDir","substring","lastIndexOf","startsWith","directoryExists","filename","path","resolveFilePath","getMockFileContent","createParents","targets","slice","filter","arg","parentDir","parts","currentPath","i","createDirectory","subCommand","packageName","prSubCommand","branchName","commandLine","currentArg","inQuote","quoteChar","char","push","createFile","isRecursive","isForce","removeFile","removeDirectory","nonFlagArgs","destination","sources","src","source","destPath","fileName","destDirPath","dirName","subdirs","dir","subdir","relativePath","filesInDir","Object","keys","indexOf","reverse","pattern","replace","regexPattern","regex","RegExp","searchPath","matches","test","filePaths","results","filePath","content","lines","header","processes","scriptPath","manPages","recursive","dirsInDir","forEach","directory","directSubdirs","directFiles"],"sources":["/Users/georgeseib/Documents/projects/cc/third/src/services/terminalService.js"],"sourcesContent":["/**\n * Terminal Service\n * \n * This module provides functions to interact with a simulated shell.\n * In a real application, these would make API calls to a backend service.\n * For this demo, we'll simulate shell commands and responses.\n */\n\n// Base directory for the file system - should match what's used in fileService\nconst BASE_DIRECTORY = '/Users/georgeseib/Documents/projects/cc/third';\n\n// In-memory filesystem to track created/modified files and directories\n// Export a getter function to allow other modules to access the filesystem\nexport const getVirtualFileSystem = () => virtualFileSystem;\n\nconst virtualFileSystem = {\n  // Initial directories\n  directories: [\n    '',  // Root\n    'src',\n    'src/components',\n    'src/services',\n    'public',\n    'node_modules'\n  ],\n  \n  // Initial files with their content\n  files: {\n    'package.json': `{\n  \"name\": \"third\",\n  \"version\": \"1.0.0\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"description\": \"Web interface with Claude chat, file viewer, and terminal\",\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-scripts\": \"^5.0.1\",\n    \"styled-components\": \"^6.1.1\",\n    \"xterm\": \"^5.3.0\",\n    \"xterm-addon-fit\": \"^0.8.0\",\n    \"axios\": \"^1.6.0\"\n  }\n}`,\n    'README.md': `# Claude Web Interface\n\nA web interface application with three panels for interacting with Claude:\n\n- **Left Panel**: Chat interface for conversing with Claude\n- **Upper Right Panel**: File viewer for browsing local repository files\n- **Bottom Right Panel**: Terminal for running commands (gh, npm, etc.)`,\n    'src/index.js': `import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './index.css';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);`,\n    'src/App.js': `import React from 'react';\nimport styled from 'styled-components';\nimport ChatWindow from './components/ChatWindow';\nimport FileViewer from './components/FileViewer';\nimport Terminal from './components/Terminal';\n\nfunction App() {\n  return (\n    <AppContainer>\n      <ChatContainer>\n        <ChatWindow />\n      </ChatContainer>\n      <FileViewerContainer>\n        <FileViewer />\n      </FileViewerContainer>\n      <TerminalContainer>\n        <Terminal />\n      </TerminalContainer>\n    </AppContainer>\n  );\n}\n\nexport default App;`,\n    'src/index.css': `body {\n  margin: 0;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}`,\n    'src/components/ChatWindow.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// Chat window component implementation\nexport default function ChatWindow() {\n  return <div>Chat Window</div>;\n}`,\n    'src/components/FileViewer.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// File viewer component implementation\nexport default function FileViewer() {\n  return <div>File Viewer</div>;\n}`,\n    'src/components/Terminal.js': `import React from 'react';\nimport styled from 'styled-components';\n\n// Terminal component implementation\nexport default function Terminal() {\n  return <div>Terminal</div>;\n}`,\n    'src/services/fileService.js': `// File service implementation`,\n    'src/services/terminalService.js': `// Terminal service implementation`,\n    'public/index.html': `<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>Claude Web Interface</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n  </body>\n</html>`,\n  }\n};\n\n/**\n * Execute a shell command\n * @param {string} command - Command to execute\n * @param {string} currentDirectory - Current working directory\n * @returns {Promise<{output: string, newDirectory: string}>} - Command output and new working directory\n */\nexport const executeCommand = async (command, currentDirectory = '') => {\n  // In a real implementation, this would call a backend API\n  // For demo purposes, we'll simulate responses to common commands\n\n  // Simulate network delay\n  await new Promise(resolve => setTimeout(resolve, 100));\n\n  // Trim command\n  command = command.trim();\n\n  // Determine the full path of the current directory\n  const workingDir = currentDirectory || '';\n  const fullPath = workingDir ? `${BASE_DIRECTORY}/${workingDir}` : BASE_DIRECTORY;\n\n  // Check for redirection\n  let redirectOutput = false;\n  let redirectAppend = false;\n  let redirectFile = '';\n  let originalCommand = command;\n\n  // Check for output redirection\n  if (command.includes('>>')) {\n    redirectOutput = true;\n    redirectAppend = true;\n    [command, redirectFile] = command.split('>>').map(part => part.trim());\n  } else if (command.includes('>')) {\n    redirectOutput = true;\n    redirectAppend = false;\n    [command, redirectFile] = command.split('>').map(part => part.trim());\n  }\n\n  // Parse command and arguments - handle quoted arguments properly\n  const args = parseCommandArgs(command);\n  const cmd = args.length > 0 ? args[0].toLowerCase() : '';\n\n  // Track the new directory (changes if cd is used)\n  let newDirectory = currentDirectory;\n\n  // Simulate command execution\n  let output = '';\n\n  try {\n    // Handle different commands\n    switch (cmd) {\n      // File system navigation\n      case 'ls':\n        output = simulateLS(args, workingDir);\n        break;\n      \n      case 'cd':\n        const cdResult = simulateCD(args, workingDir);\n        output = cdResult.output;\n        newDirectory = cdResult.newDirectory;\n        break;\n      \n      case 'pwd':\n        output = simulatePWD(workingDir);\n        break;\n      \n      // File operations\n      case 'cat':\n        output = simulateCAT(args, workingDir);\n        break;\n      \n      case 'touch':\n        output = simulateTOUCH(args, workingDir);\n        break;\n      \n      case 'mkdir':\n        output = simulateMKDIR(args, workingDir);\n        break;\n      \n      case 'rm':\n        output = simulateRM(args, workingDir);\n        break;\n      \n      case 'cp':\n        output = simulateCP(args, workingDir);\n        break;\n      \n      case 'mv':\n        output = simulateMV(args, workingDir);\n        break;\n      \n      case 'find':\n        output = simulateFIND(args, workingDir);\n        break;\n      \n      case 'grep':\n        output = simulateGREP(args, workingDir);\n        break;\n      \n      // Text output\n      case 'echo':\n        output = simulateECHO(args);\n        break;\n      \n      // External tools\n      case 'npm':\n        output = simulateNPM(args, workingDir);\n        break;\n      \n      case 'node':\n        output = simulateNODE(args, workingDir);\n        break;\n      \n      case 'gh':\n        output = simulateGH(args, workingDir);\n        break;\n      \n      case 'git':\n        output = simulateGit(args, workingDir);\n        break;\n      \n      // System commands\n      case 'ps':\n        output = simulatePS(args);\n        break;\n      \n      case 'whoami':\n        output = 'user';\n        break;\n      \n      case 'date':\n        output = new Date().toString();\n        break;\n      \n      case 'help':\n        output = getHelpText();\n        break;\n      \n      case 'man':\n        output = simulateMAN(args);\n        break;\n      \n      case 'clear':\n        // The clear command returns a special signal to clear the terminal\n        return { output: 'CLEAR_TERMINAL', newDirectory };\n      \n      case '':\n        // Empty command, do nothing\n        output = '';\n        break;\n      \n      default:\n        // Check if this is an executable file in the current directory\n        if (fileExists(`${workingDir ? workingDir + '/' : ''}${cmd}`)) {\n          output = `Simulated execution of ${cmd}`;\n        } else {\n          output = `Command not found: ${cmd}\\nType 'help' to see available commands.`;\n        }\n    }\n  } catch (error) {\n    output = `Error: ${error.message}`;\n  }\n\n  return { output, newDirectory };\n};\n\n/**\n * Simulate the 'ls' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateLS(args, workingDir) {\n  // Check for -l flag\n  const isLongFormat = args.includes('-l');\n  \n  // Get mock file listing based on the current directory\n  const files = getMockFileListing(workingDir);\n  \n  if (isLongFormat) {\n    // Format like a real ls -l command\n    return files.map(file => {\n      const isDir = file.type === 'folder';\n      const permissions = isDir ? 'drwxr-xr-x' : '-rw-r--r--';\n      const size = isDir ? 4096 : Math.floor(Math.random() * 10000);\n      const date = new Date().toLocaleDateString('en-US', { \n        month: 'short', \n        day: 'numeric', \n        hour: '2-digit', \n        minute: '2-digit' \n      });\n      return `${permissions} 1 user group ${size.toString().padStart(6)} ${date} ${file.name}${isDir ? '/' : ''}`;\n    }).join('\\n');\n  } else {\n    // Simple format\n    return files.map(file => {\n      return file.type === 'folder' ? `${file.name}/` : file.name;\n    }).join('  ');\n  }\n}\n\n/**\n * Simulate the 'cd' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {{output: string, newDirectory: string}} - Command output and new working directory\n */\nfunction simulateCD(args, workingDir) {\n  if (args.length < 2) {\n    // cd without arguments goes to home directory\n    return { output: '', newDirectory: '' };\n  }\n  \n  const target = args[1];\n  \n  if (target === '..') {\n    // Go up one directory\n    if (!workingDir || !workingDir.includes('/')) {\n      return { output: '', newDirectory: '' };\n    }\n    \n    const newDir = workingDir.substring(0, workingDir.lastIndexOf('/'));\n    return { output: '', newDirectory: newDir };\n  }\n  \n  if (target === '.') {\n    // Stay in current directory\n    return { output: '', newDirectory: workingDir };\n  }\n  \n  if (target.startsWith('/')) {\n    // Absolute path (within our mock filesystem)\n    const newDir = target.substring(1); // Remove leading slash\n    \n    // Check if directory exists\n    if (directoryExists(newDir)) {\n      return { output: '', newDirectory: newDir };\n    } else {\n      return { \n        output: `cd: ${target}: No such file or directory`, \n        newDirectory: workingDir \n      };\n    }\n  }\n  \n  // Relative path\n  const newDir = workingDir ? `${workingDir}/${target}` : target;\n  \n  // Check if directory exists\n  if (directoryExists(newDir)) {\n    return { output: '', newDirectory: newDir };\n  } else {\n    return { \n      output: `cd: ${target}: No such file or directory`, \n      newDirectory: workingDir \n    };\n  }\n}\n\n/**\n * Simulate the 'pwd' command\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulatePWD(workingDir) {\n  return workingDir ? `/${workingDir}` : '/';\n}\n\n/**\n * Simulate the 'cat' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateCAT(args, workingDir) {\n  if (args.length < 2) {\n    return 'cat: missing file operand';\n  }\n  \n  const filename = args[1];\n  const path = resolveFilePath(filename, workingDir);\n  \n  // Check if file exists\n  if (fileExists(path)) {\n    return getMockFileContent(path);\n  } else {\n    return `cat: ${filename}: No such file or directory`;\n  }\n}\n\n/**\n * Simulate the 'mkdir' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateMKDIR(args, workingDir) {\n  if (args.length < 2) {\n    return 'mkdir: missing operand';\n  }\n  \n  // Check for -p flag (create parent directories as needed)\n  const createParents = args.includes('-p');\n  \n  // Get targets (ignore option flags)\n  const targets = args.slice(1).filter(arg => !arg.startsWith('-'));\n  \n  if (targets.length === 0) {\n    return 'mkdir: missing operand';\n  }\n  \n  for (const target of targets) {\n    const path = resolveFilePath(target, workingDir);\n    \n    // Check if directory already exists\n    if (directoryExists(path)) {\n      if (!createParents) {\n        return `mkdir: cannot create directory '${target}': File exists`;\n      }\n      // With -p, we just continue if the directory exists\n      continue;\n    }\n    \n    // Check if a file with the same name exists\n    if (fileExists(path)) {\n      return `mkdir: cannot create directory '${target}': File exists`;\n    }\n    \n    // Check if parent directory exists\n    const parentDir = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';\n    \n    if (parentDir && !directoryExists(parentDir)) {\n      if (createParents) {\n        // Create parent directories recursively\n        const parts = path.split('/');\n        let currentPath = '';\n        \n        for (let i = 0; i < parts.length; i++) {\n          if (parts[i] === '') continue;\n          \n          if (currentPath === '') {\n            currentPath = parts[i];\n          } else {\n            currentPath += '/' + parts[i];\n          }\n          \n          if (!directoryExists(currentPath)) {\n            createDirectory(currentPath);\n          }\n        }\n      } else {\n        return `mkdir: cannot create directory '${target}': No such file or directory`;\n      }\n    } else {\n      // Create the directory\n      createDirectory(path);\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Simulate the 'npm' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateNPM(args, workingDir) {\n  if (args.length < 2) {\n    return 'npm: missing command';\n  }\n  \n  const subCommand = args[1];\n  \n  switch (subCommand) {\n    case 'start':\n      return 'Starting development server...\\n\\nCompiled successfully!\\n\\nYou can now view the app in the browser.\\n\\n  Local:            http://localhost:3000\\n  On Your Network:  http://192.168.0.45:3000';\n    \n    case 'test':\n      return 'PASS  src/__tests__/app.test.js\\nPASS  src/__tests__/components.test.js\\n\\nTest Suites: 2 passed, 2 total\\nTests:       7 passed, 7 total\\nSnapshots:   0 total\\nTime:        1.234s';\n    \n    case 'build':\n      return 'Creating an optimized production build...\\nCompiled successfully.\\n\\nFile sizes after gzip:\\n\\n  142.32 KB  build/static/js/main.a1b2c3d4.js\\n  23.45 KB   build/static/css/main.a1b2c3d4.css';\n    \n    case 'install':\n      const packageName = args.length > 2 ? args[2] : '';\n      if (packageName) {\n        return `+ ${packageName}@1.2.3\\nadded 42 packages from 23 contributors in 2.5s`;\n      } else {\n        return 'added 1344 packages in 30s';\n      }\n    \n    default:\n      return `Unknown npm command: ${subCommand}`;\n  }\n}\n\n/**\n * Simulate the 'gh' (GitHub CLI) command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGH(args, workingDir) {\n  if (args.length < 2) {\n    return 'gh: missing command';\n  }\n  \n  const subCommand = args[1];\n  \n  switch (subCommand) {\n    case 'pr':\n      if (args.length < 3) {\n        return 'gh pr: missing subcommand';\n      }\n      \n      const prSubCommand = args[2];\n      \n      switch (prSubCommand) {\n        case 'list':\n          return 'Showing 2 of 2 open pull requests in username/repo\\n\\n#42  Update documentation  user1  [feature/docs]  1d\\n#41  Fix terminal component  user2  [bugfix/terminal]  2d';\n        \n        case 'create':\n          return 'Creating pull request for feature-branch into main in username/repo\\n\\nPull request created: https://github.com/username/repo/pull/43';\n        \n        default:\n          return `Unknown gh pr command: ${prSubCommand}`;\n      }\n    \n    case 'issue':\n      return 'Showing 3 of 3 open issues in username/repo\\n\\n#39  Improve performance  user1  2d\\n#38  Add test coverage  user2  3d\\n#37  Update dependencies  user3  1w';\n    \n    default:\n      return `Unknown gh command: ${subCommand}`;\n  }\n}\n\n/**\n * Simulate the 'git' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGit(args, workingDir) {\n  if (args.length < 2) {\n    return 'git: missing command';\n  }\n  \n  const subCommand = args[1];\n  \n  switch (subCommand) {\n    case 'status':\n      return 'On branch main\\nYour branch is up to date with \\'origin/main\\'.\\n\\nChanges not staged for commit:\\n  (use \"git add <file>...\" to update what will be committed)\\n  (use \"git restore <file>...\" to discard changes in working directory)\\n        modified:   src/components/Terminal.js\\n        modified:   src/components/FileViewer.js\\n\\nno changes added to commit (use \"git add\" and/or \"git commit -a\")';\n    \n    case 'add':\n      return '';\n    \n    case 'commit':\n      return '[main a1b2c3d] Update terminal and file viewer components\\n 2 files changed, 150 insertions(+), 20 deletions(-)';\n    \n    case 'push':\n      return 'Enumerating objects: 7, done.\\nCounting objects: 100% (7/7), done.\\nDelta compression using up to 8 threads\\nCompressing objects: 100% (4/4), done.\\nWriting objects: 100% (4/4), 1.23 KiB | 1.23 MiB/s, done.\\nTotal 4 (delta 3), reused 0 (delta 0), pack-reused 0\\nremote: Resolving deltas: 100% (3/3), completed with 3 local objects.\\nTo github.com:username/repo.git\\n   a1b2c3d..e4f5g6h  main -> main';\n    \n    case 'log':\n      return 'commit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t\\nAuthor: User <user@example.com>\\nDate:   Mon Mar 1 12:34:56 2024 -0800\\n\\n    Update terminal and file viewer components\\n\\ncommit b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\\nAuthor: User <user@example.com>\\nDate:   Sun Feb 29 12:34:56 2024 -0800\\n\\n    Initial commit';\n    \n    case 'branch':\n      return '* main\\n  feature/file-viewer\\n  feature/terminal';\n    \n    case 'checkout':\n      const branchName = args.length > 2 ? args[2] : 'main';\n      return `Switched to branch '${branchName}'`;\n    \n    default:\n      return `Unknown git command: ${subCommand}`;\n  }\n}\n\n/**\n * Get help text for available commands\n * @returns {string} - Help text\n */\n/**\n * Parse command arguments, handling quoted strings correctly\n * @param {string} commandLine - Command line to parse\n * @returns {string[]} - Array of parsed arguments\n */\nfunction parseCommandArgs(commandLine) {\n  const args = [];\n  let currentArg = '';\n  let inQuote = false;\n  let quoteChar = '';\n  \n  for (let i = 0; i < commandLine.length; i++) {\n    const char = commandLine[i];\n    \n    if ((char === '\"' || char === \"'\") && (!inQuote || quoteChar === char)) {\n      if (inQuote) {\n        inQuote = false;\n        quoteChar = '';\n      } else {\n        inQuote = true;\n        quoteChar = char;\n      }\n      continue;\n    }\n    \n    if (char === ' ' && !inQuote) {\n      if (currentArg) {\n        args.push(currentArg);\n        currentArg = '';\n      }\n      continue;\n    }\n    \n    currentArg += char;\n  }\n  \n  if (currentArg) {\n    args.push(currentArg);\n  }\n  \n  return args;\n}\n\n/**\n * Simulate the 'echo' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulateECHO(args) {\n  // Skip the 'echo' command itself\n  return args.slice(1).join(' ');\n}\n\n/**\n * Simulate the 'touch' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateTOUCH(args, workingDir) {\n  if (args.length < 2) {\n    return 'touch: missing file operand';\n  }\n  \n  // Get all file operands (skipping the command itself)\n  const files = args.slice(1);\n  \n  for (const file of files) {\n    const path = resolveFilePath(file, workingDir);\n    \n    // Check if parent directory exists\n    const parentDir = path.includes('/') ? path.substring(0, path.lastIndexOf('/')) : '';\n    \n    if (parentDir && !directoryExists(parentDir)) {\n      return `touch: cannot touch '${file}': No such file or directory`;\n    }\n    \n    // Create the file if it doesn't exist\n    if (!fileExists(path)) {\n      createFile(path, '');\n    } else {\n      // In a real touch, this would update the timestamp\n      // We'll just do nothing for existing files\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Simulate the 'rm' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateRM(args, workingDir) {\n  if (args.length < 2) {\n    return 'rm: missing operand';\n  }\n  \n  const isRecursive = args.includes('-r') || args.includes('-rf') || args.includes('-fr');\n  const isForce = args.includes('-f') || args.includes('-rf') || args.includes('-fr');\n  \n  // Get targets (ignore option flags)\n  const targets = args.slice(1).filter(arg => !arg.startsWith('-'));\n  \n  if (targets.length === 0) {\n    return 'rm: missing operand';\n  }\n  \n  for (const target of targets) {\n    const path = resolveFilePath(target, workingDir);\n    \n    if (fileExists(path)) {\n      // Remove file\n      removeFile(path);\n    } else if (directoryExists(path)) {\n      // Remove directory\n      if (!isRecursive) {\n        return `rm: cannot remove '${target}': Is a directory`;\n      } else {\n        removeDirectory(path, true);\n      }\n    } else if (!isForce) {\n      return `rm: cannot remove '${target}': No such file or directory`;\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Simulate the 'cp' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateCP(args, workingDir) {\n  if (args.length < 3) {\n    return 'cp: missing file operand';\n  }\n  \n  const isRecursive = args.includes('-r') || args.includes('-R');\n  \n  // Get all arguments that aren't flags\n  const nonFlagArgs = args.filter(arg => !arg.startsWith('-'));\n  \n  // Need at least a source and destination\n  if (nonFlagArgs.length < 3) {\n    return 'cp: missing destination file operand after ' + nonFlagArgs[1];\n  }\n  \n  // Last argument is the destination\n  const destination = resolveFilePath(nonFlagArgs[nonFlagArgs.length - 1], workingDir);\n  \n  // All other non-flag arguments except the command itself are sources\n  const sources = nonFlagArgs.slice(1, nonFlagArgs.length - 1).map(src => \n    resolveFilePath(src, workingDir)\n  );\n  \n  // If copying multiple sources, destination must be a directory\n  if (sources.length > 1 && !directoryExists(destination)) {\n    return `cp: target '${nonFlagArgs[nonFlagArgs.length - 1]}' is not a directory`;\n  }\n  \n  for (const source of sources) {\n    if (fileExists(source)) {\n      // Copying a file\n      \n      // Determine the destination path\n      let destPath = destination;\n      if (directoryExists(destination)) {\n        // If destination is a directory, copy into it with the same name\n        const fileName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destPath = destination + '/' + fileName;\n      }\n      \n      // Copy the file content\n      createFile(destPath, virtualFileSystem.files[source]);\n      \n    } else if (directoryExists(source)) {\n      // Copying a directory\n      \n      if (!isRecursive) {\n        return `cp: -r not specified; omitting directory '${source}'`;\n      }\n      \n      // Determine the destination directory path\n      let destDirPath = destination;\n      if (directoryExists(destination)) {\n        // If destination already exists as a directory, create a subdirectory\n        const dirName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destDirPath = destination + '/' + dirName;\n        \n        // Create the destination directory if it doesn't exist\n        if (!directoryExists(destDirPath)) {\n          createDirectory(destDirPath);\n        }\n      } else {\n        // Create the destination directory\n        createDirectory(destDirPath);\n      }\n      \n      // Copy all files and subdirectories recursively\n      // Find all subdirectories\n      const subdirs = virtualFileSystem.directories.filter(dir => \n        dir !== source && dir.startsWith(source + '/')\n      );\n      \n      // Create all subdirectories in the destination\n      for (const subdir of subdirs) {\n        const relativePath = subdir.substring(source.length);\n        createDirectory(destDirPath + relativePath);\n      }\n      \n      // Copy all files\n      const filesInDir = Object.keys(virtualFileSystem.files).filter(file => \n        file.startsWith(source + '/')\n      );\n      \n      for (const file of filesInDir) {\n        const relativePath = file.substring(source.length);\n        createFile(destDirPath + relativePath, virtualFileSystem.files[file]);\n      }\n      \n    } else {\n      return `cp: cannot stat '${nonFlagArgs[sources.indexOf(source) + 1]}': No such file or directory`;\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Simulate the 'mv' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateMV(args, workingDir) {\n  if (args.length < 3) {\n    return 'mv: missing file operand';\n  }\n  \n  // Get all arguments except the command itself\n  const nonFlagArgs = args.filter(arg => !arg.startsWith('-'));\n  \n  // Need at least a source and destination\n  if (nonFlagArgs.length < 3) {\n    return 'mv: missing destination file operand after ' + nonFlagArgs[1];\n  }\n  \n  // Last argument is the destination\n  const destination = resolveFilePath(nonFlagArgs[nonFlagArgs.length - 1], workingDir);\n  \n  // All other non-flag arguments except the command itself are sources\n  const sources = nonFlagArgs.slice(1, nonFlagArgs.length - 1).map(src => \n    resolveFilePath(src, workingDir)\n  );\n  \n  // If moving multiple sources, destination must be a directory\n  if (sources.length > 1 && !directoryExists(destination)) {\n    return `mv: target '${nonFlagArgs[nonFlagArgs.length - 1]}' is not a directory`;\n  }\n  \n  for (const source of sources) {\n    if (fileExists(source)) {\n      // Moving a file\n      \n      // Determine the destination path\n      let destPath = destination;\n      if (directoryExists(destination)) {\n        // If destination is a directory, move into it with the same name\n        const fileName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destPath = destination + '/' + fileName;\n      }\n      \n      // Move the file (copy then delete)\n      createFile(destPath, virtualFileSystem.files[source]);\n      removeFile(source);\n      \n    } else if (directoryExists(source)) {\n      // Moving a directory\n      \n      // Determine the destination directory path\n      let destDirPath = destination;\n      if (directoryExists(destination)) {\n        // If destination already exists as a directory, create a subdirectory\n        const dirName = source.includes('/') ? source.substring(source.lastIndexOf('/') + 1) : source;\n        destDirPath = destination + '/' + dirName;\n        \n        // Create the destination directory if it doesn't exist\n        if (!directoryExists(destDirPath)) {\n          createDirectory(destDirPath);\n        }\n      } else {\n        // Create the destination directory\n        createDirectory(destDirPath);\n      }\n      \n      // Move all files and subdirectories\n      // Find all subdirectories\n      const subdirs = virtualFileSystem.directories.filter(dir => \n        dir !== source && dir.startsWith(source + '/')\n      );\n      \n      // Create all subdirectories in the destination\n      for (const subdir of subdirs) {\n        const relativePath = subdir.substring(source.length);\n        createDirectory(destDirPath + relativePath);\n      }\n      \n      // Move all files\n      const filesInDir = Object.keys(virtualFileSystem.files).filter(file => \n        file.startsWith(source + '/')\n      );\n      \n      for (const file of filesInDir) {\n        const relativePath = file.substring(source.length);\n        createFile(destDirPath + relativePath, virtualFileSystem.files[file]);\n        removeFile(file);\n      }\n      \n      // Remove the source directory and all subdirectories\n      for (const subdir of [...subdirs].reverse()) {\n        removeDirectory(subdir);\n      }\n      removeDirectory(source);\n      \n    } else {\n      return `mv: cannot stat '${nonFlagArgs[sources.indexOf(source) + 1]}': No such file or directory`;\n    }\n  }\n  \n  return '';\n}\n\n/**\n * Simulate the 'find' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateFIND(args, workingDir) {\n  // Basic implementation of find\n  // find [path] -name \"pattern\"\n  \n  let path = '.';\n  let pattern = null;\n  \n  // Parse arguments\n  for (let i = 1; i < args.length; i++) {\n    if (args[i] === '-name' && i + 1 < args.length) {\n      pattern = args[i + 1];\n      i++; // Skip the next argument\n    } else if (!args[i].startsWith('-') && i === 1) {\n      path = args[i];\n    }\n  }\n  \n  if (!pattern) {\n    return 'find: missing arguments';\n  }\n  \n  // Remove quotes if present\n  pattern = pattern.replace(/^['\"]|['\"]$/g, '');\n  \n  // Convert glob pattern to regex\n  const regexPattern = pattern\n    .replace(/\\./g, '\\\\.')\n    .replace(/\\*/g, '.*')\n    .replace(/\\?/g, '.');\n  \n  const regex = new RegExp(`^${regexPattern}$`);\n  \n  // Get file listing for the path\n  const searchPath = path === '.' ? workingDir : resolveFilePath(path, workingDir);\n  \n  // In a real implementation, this would search for files\n  // For our demo, we'll return a simulated result\n  \n  // Create a reasonable list of matches based on the pattern\n  const matches = [];\n  const files = getMockFileListing(searchPath);\n  \n  for (const file of files) {\n    if (regex.test(file.name)) {\n      matches.push(`${searchPath ? searchPath + '/' : ''}${file.name}`);\n    }\n  }\n  \n  return matches.length > 0 ? matches.join('\\n') : '';\n}\n\n/**\n * Simulate the 'grep' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateGREP(args, workingDir) {\n  if (args.length < 3) {\n    return 'grep: missing pattern';\n  }\n  \n  const pattern = args[1];\n  const filePaths = args.slice(2);\n  \n  // In a real implementation, this would search file contents\n  // For our demo, we'll return simulated results\n  \n  const results = [];\n  \n  for (const filePath of filePaths) {\n    const path = resolveFilePath(filePath, workingDir);\n    \n    if (fileExists(path)) {\n      const content = getMockFileContent(path);\n      const lines = content.split('\\n');\n      \n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].includes(pattern)) {\n          results.push(`${filePath}:${i + 1}: ${lines[i]}`);\n        }\n      }\n    } else {\n      results.push(`grep: ${filePath}: No such file or directory`);\n    }\n  }\n  \n  return results.join('\\n');\n}\n\n/**\n * Simulate the 'ps' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulatePS(args) {\n  const header = '  PID TTY          TIME CMD';\n  const processes = [\n    ' 1234 pts/0    00:00:01 bash',\n    ' 5678 pts/0    00:00:00 npm',\n    ' 9012 pts/0    00:00:12 node',\n    '13456 pts/0    00:00:00 ps'\n  ];\n  \n  return [header, ...processes].join('\\n');\n}\n\n/**\n * Simulate the 'node' command\n * @param {string[]} args - Command arguments\n * @param {string} workingDir - Current working directory\n * @returns {string} - Command output\n */\nfunction simulateNODE(args, workingDir) {\n  if (args.length === 1) {\n    return 'Welcome to Node.js v18.16.0.\\nType \".help\" for more information.';\n  }\n  \n  const scriptPath = args[1];\n  const path = resolveFilePath(scriptPath, workingDir);\n  \n  if (fileExists(path)) {\n    return `Simulated execution of Node.js script: ${scriptPath}`;\n  } else {\n    return `Error: Cannot find module '${scriptPath}'`;\n  }\n}\n\n/**\n * Simulate the 'man' command\n * @param {string[]} args - Command arguments\n * @returns {string} - Command output\n */\nfunction simulateMAN(args) {\n  if (args.length < 2) {\n    return 'What manual page do you want?';\n  }\n  \n  const command = args[1];\n  \n  const manPages = {\n    'ls': 'LS(1)                    User Commands                   LS(1)\\n\\nNAME\\n       ls - list directory contents\\n\\nSYNOPSIS\\n       ls [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       List information about the FILEs (the current directory by default).',\n    'cd': 'CD(1)                    User Commands                   CD(1)\\n\\nNAME\\n       cd - change directory\\n\\nSYNOPSIS\\n       cd [directory]\\n\\nDESCRIPTION\\n       Change the current directory to the specified directory.',\n    'cat': 'CAT(1)                  User Commands                   CAT(1)\\n\\nNAME\\n       cat - concatenate files and print on the standard output\\n\\nSYNOPSIS\\n       cat [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       Concatenate FILE(s) to standard output.',\n    'mkdir': 'MKDIR(1)               User Commands                 MKDIR(1)\\n\\nNAME\\n       mkdir - make directories\\n\\nSYNOPSIS\\n       mkdir [OPTION]... DIRECTORY...\\n\\nDESCRIPTION\\n       Create the DIRECTORY(ies), if they do not already exist.',\n    'touch': 'TOUCH(1)               User Commands                 TOUCH(1)\\n\\nNAME\\n       touch - change file timestamps\\n\\nSYNOPSIS\\n       touch [OPTION]... FILE...\\n\\nDESCRIPTION\\n       Update the access and modification times of each FILE to the current time.',\n    'rm': 'RM(1)                    User Commands                   RM(1)\\n\\nNAME\\n       rm - remove files or directories\\n\\nSYNOPSIS\\n       rm [OPTION]... [FILE]...\\n\\nDESCRIPTION\\n       Remove (unlink) the FILE(s).',\n    'cp': 'CP(1)                    User Commands                   CP(1)\\n\\nNAME\\n       cp - copy files and directories\\n\\nSYNOPSIS\\n       cp [OPTION]... SOURCE DEST\\n\\nDESCRIPTION\\n       Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.',\n    'mv': 'MV(1)                    User Commands                   MV(1)\\n\\nNAME\\n       mv - move (rename) files\\n\\nSYNOPSIS\\n       mv [OPTION]... SOURCE DEST\\n\\nDESCRIPTION\\n       Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.',\n    'find': 'FIND(1)                  User Commands                 FIND(1)\\n\\nNAME\\n       find - search for files in a directory hierarchy\\n\\nSYNOPSIS\\n       find [path...] [expression]\\n\\nDESCRIPTION\\n       Search for files in a directory hierarchy.',\n    'grep': 'GREP(1)                  User Commands                 GREP(1)\\n\\nNAME\\n       grep - print lines that match patterns\\n\\nSYNOPSIS\\n       grep [OPTION...] PATTERNS [FILE...]\\n\\nDESCRIPTION\\n       Search for PATTERNS in each FILE.',\n    'echo': 'ECHO(1)                  User Commands                 ECHO(1)\\n\\nNAME\\n       echo - display a line of text\\n\\nSYNOPSIS\\n       echo [SHORT-OPTION]... [STRING]...\\n\\nDESCRIPTION\\n       Echo the STRING(s) to standard output.',\n    'pwd': 'PWD(1)                   User Commands                  PWD(1)\\n\\nNAME\\n       pwd - print name of current/working directory\\n\\nSYNOPSIS\\n       pwd [OPTION]...\\n\\nDESCRIPTION\\n       Print the full filename of the current working directory.',\n  };\n  \n  return manPages[command] || `No manual entry for ${command}`;\n}\n\nfunction getHelpText() {\n  return `\nAvailable commands:\n\nFile Operations:\n  ls [options]           List directory contents\n  cd <directory>         Change directory\n  pwd                    Print working directory\n  touch <file>           Create an empty file\n  mkdir <directory>      Create directory\n  rm [-rf] <file/dir>    Remove files or directories\n  cp [-r] <src> <dst>    Copy files or directories\n  mv <src> <dst>         Move/rename files or directories\n  cat <file>             Display file contents\n  find <path> -name <p>  Search for files\n  grep <pattern> <file>  Search for a pattern in files\n\nGit Commands:\n  git status             Show git status\n  git add <file>         Stage changes\n  git commit -m <msg>    Commit changes\n  git push               Push changes\n  git log                Show commit history\n  git branch             List branches\n  git checkout <branch>  Switch branches\n  \nnpm Commands:\n  npm start              Start development server\n  npm test               Run tests\n  npm build              Build for production\n  npm install [pkg]      Install dependencies\n  \nGitHub CLI:\n  gh pr list             List pull requests\n  gh pr create           Create pull request\n  gh issue               List issues\n  \nSystem Commands:\n  echo <text>            Display a line of text\n  date                   Show the current date and time\n  ps                     Report process status\n  whoami                 Print current user\n  man <command>          Display manual page\n  clear                  Clear the terminal screen\n  help                   Show this help\n`.trim();\n}\n\n/**\n * Check if a directory exists in our virtual filesystem\n * @param {string} path - Directory path\n * @returns {boolean} - True if directory exists\n */\nfunction directoryExists(path) {\n  return virtualFileSystem.directories.includes(path);\n}\n\n/**\n * Create a directory in our virtual filesystem\n * @param {string} path - Directory path\n * @returns {boolean} - True if directory was created successfully\n */\nfunction createDirectory(path) {\n  if (directoryExists(path)) {\n    return false; // Directory already exists\n  }\n  \n  // Add directory to virtual filesystem\n  virtualFileSystem.directories.push(path);\n  return true;\n}\n\n/**\n * Check if a file exists in our virtual filesystem\n * @param {string} path - File path\n * @returns {boolean} - True if file exists\n */\nfunction fileExists(path) {\n  return path in virtualFileSystem.files;\n}\n\n/**\n * Create a file in our virtual filesystem\n * @param {string} path - File path\n * @param {string} content - File content\n * @returns {boolean} - True if file was created successfully\n */\nfunction createFile(path, content = '') {\n  if (fileExists(path)) {\n    return false; // File already exists\n  }\n  \n  // Add file to virtual filesystem\n  virtualFileSystem.files[path] = content;\n  return true;\n}\n\n/**\n * Remove a file from our virtual filesystem\n * @param {string} path - File path\n * @returns {boolean} - True if file was removed successfully\n */\nfunction removeFile(path) {\n  if (!fileExists(path)) {\n    return false; // File doesn't exist\n  }\n  \n  // Remove file from virtual filesystem\n  delete virtualFileSystem.files[path];\n  return true;\n}\n\n/**\n * Remove a directory from our virtual filesystem\n * @param {string} path - Directory path\n * @param {boolean} recursive - Whether to remove subdirectories and files\n * @returns {boolean} - True if directory was removed successfully\n */\nfunction removeDirectory(path, recursive = false) {\n  if (!directoryExists(path)) {\n    return false; // Directory doesn't exist\n  }\n  \n  // Check if directory is empty or recursive flag is set\n  const filesInDir = Object.keys(virtualFileSystem.files).filter(file => \n    file.startsWith(path + '/') || file === path\n  );\n  \n  const dirsInDir = virtualFileSystem.directories.filter(dir => \n    dir !== path && dir.startsWith(path + '/')\n  );\n  \n  if ((filesInDir.length > 0 || dirsInDir.length > 0) && !recursive) {\n    return false; // Directory not empty and recursive flag not set\n  }\n  \n  // Remove files in directory if recursive\n  if (recursive) {\n    filesInDir.forEach(file => {\n      delete virtualFileSystem.files[file];\n    });\n    \n    // Remove subdirectories\n    virtualFileSystem.directories = virtualFileSystem.directories.filter(dir => \n      dir !== path && !dir.startsWith(path + '/')\n    );\n  } else {\n    // Just remove the directory\n    virtualFileSystem.directories = virtualFileSystem.directories.filter(dir => \n      dir !== path\n    );\n  }\n  \n  return true;\n}\n\n/**\n * Resolve a file path based on the current working directory\n * @param {string} filename - File name or path\n * @param {string} workingDir - Current working directory\n * @returns {string} - Resolved file path\n */\nfunction resolveFilePath(filename, workingDir) {\n  if (filename.startsWith('/')) {\n    // Absolute path (within our mock filesystem)\n    return filename.substring(1); // Remove leading slash\n  } else {\n    // Relative path\n    return workingDir ? `${workingDir}/${filename}` : filename;\n  }\n}\n\n// Removed previous implementation\n\n/**\n * Get file content from our virtual filesystem\n * @param {string} filePath - Path to the file\n * @returns {string} - File content\n */\nfunction getMockFileContent(filePath) {\n  // Return the file content from the virtual filesystem\n  if (fileExists(filePath)) {\n    return virtualFileSystem.files[filePath];\n  }\n  \n  return `// File ${filePath} not found`;\n}\n\n/**\n * Get mock file listing based on directory\n * @param {string} directory - Directory path\n * @returns {Array} - Array of file and directory objects\n */\nfunction getMockFileListing(directory) {\n  // Get all subdirectories directly under the specified directory\n  const directSubdirs = virtualFileSystem.directories.filter(dir => {\n    if (directory === '') {\n      // For root directory, get top-level dirs (no slashes)\n      return dir !== '' && !dir.includes('/');\n    } else {\n      // For other directories, get direct children\n      return dir !== directory && \n             dir.startsWith(directory + '/') && \n             dir.substring(directory.length + 1).indexOf('/') === -1;\n    }\n  }).map(dir => {\n    return {\n      name: directory === '' ? dir : dir.substring(directory.length + 1),\n      type: 'folder'\n    };\n  });\n  \n  // Get all files directly under the specified directory\n  const directFiles = Object.keys(virtualFileSystem.files).filter(file => {\n    if (directory === '') {\n      // For root directory, get top-level files (no slashes)\n      return !file.includes('/');\n    } else {\n      // For other directories, get direct children\n      return file.startsWith(directory + '/') && \n             file.substring(directory.length + 1).indexOf('/') === -1;\n    }\n  }).map(file => {\n    return {\n      name: directory === '' ? file : file.substring(directory.length + 1),\n      type: 'file'\n    };\n  });\n  \n  // Combine directories and files\n  return [...directSubdirs, ...directFiles];\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAMA,cAAc,GAAG,+CAA+C;;AAEtE;AACA;AACA,OAAO,MAAMC,oBAAoB,GAAGA,CAAA,KAAMC,iBAAiB;AAE3D,MAAMA,iBAAiB,GAAG;EACxB;EACAC,WAAW,EAAE,CACX,EAAE;EAAG;EACL,KAAK,EACL,gBAAgB,EAChB,cAAc,EACd,QAAQ,EACR,cAAc,CACf;EAED;EACAC,KAAK,EAAE;IACL,cAAc,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACE,WAAW,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,wEAAwE;IACpE,cAAc,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;IACC,YAAY,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;IAChB,eAAe,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACE,8BAA8B,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA,EAAE;IACE,8BAA8B,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA,EAAE;IACE,4BAA4B,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA,EAAE;IACE,6BAA6B,EAAE,gCAAgC;IAC/D,iCAAiC,EAAE,oCAAoC;IACvE,mBAAmB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAG,MAAAA,CAAOC,OAAO,EAAEC,gBAAgB,GAAG,EAAE,KAAK;EACtE;EACA;;EAEA;EACA,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;;EAEtD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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}